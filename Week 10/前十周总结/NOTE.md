## 前十周总结
- 1~5周总结（编程与算法训练）
1第一周主要实现一个小游戏的开发(TicTacToc)
实现井字棋的要点技巧：
(1)找到合适的数据结构来表示棋盘（二维数组）
(2)满足交换率的运算实现轮询两个数字，来实现交替落子（121212.....）
紧接着实现了人机对战，这一部分花了一段时间，还是不能完全理解。
第三小节学了异步编程小小的基础，实现了红黄绿灯问题。
前端中实现异步场景有以下情况：
- 1回调（传统模式）
- 2 Promise（es6中提出的异步解决方案，目前得到广泛的应用）
- 3 async/await（Promise的语法糖，形式上类似同步代码，但其实是异步）

2第二周实现了地图寻路。
前三节可视化了一个地图编辑器，对可视化有了一个初步的印象，然后就是广度优先搜索，广搜
这个算法比较笨重，性能一般，就像大海捞针一样。后面几节就用a星寻路优化算法，并且利用二叉堆优化数据结构，使得性能有一定的提高。

3第三周使用ll算法构建ast
最开始对产生式不是很了解，看到中间几节有点吃力，后面慢慢的理解了。
AST 叫做抽象语法树。我们的代码在计算机的分析过程中，首先就是把编程语言去分词，在分词之后就让它构成这种层层相互嵌套的语法树的树形结构。最后才是去解析代码去执行。
构建抽象语法树的过程又被称为语法分析。而最著名的语法分析算法的核心的思想有两种：
LL 算法
LR 算法
这里面的 L 是 Left 的缩写，LL 算法就是从左到右扫描，然后从左到右规约的，也是 Left Left 算法，第一个 Left 就是从左到右扫描，第二个 Left 就是从左到右规约。
以四则运算为例，
第一步借用正则产生token，进行词法分析，语法分析，定义表达式，最后实现了四则运算的解析。整体来说比较复杂。

4第四周就是字符串分析算法的学习
KMP算法定义：
快速的从一个主串中找出一个你想要的子串 —— 这里面的主串就是 source 串，而要寻找的 子串 就是 pattern 串 也叫 模式串。
KMP算法匹配过程关键步骤：
以一个例子入手，假设现在我们有两串字符：
主串 (source)：ABABABABABAAABABAA
模式串 (pattern)：AAAB
KMP算法可以做到仅仅后移模式串，比较指针不回溯！
比如我们现在有一串字符AB ... ... ABX ... ...， 这里面 ... 代表着多个任意字符，而 X 代表的就是跟随在 AB 这个公共后缀的字符。X 也能理解为模式串和主串第一个匹配失败的位置。这个时候我们只需要把 公共前缀 移到 公共后缀所在的位置，就可以继续往后匹配了，这个就是我们刚刚例子里面所讲到的，那么我们也证明了前缀和后缀之间是不会有可以匹配上的情况的。那么如果有，证明我们选择的 公共前后缀 不是最长的公共前后缀。
什么意思呢？就是在匹配失败的位置前面的字符当中，还有更长的前后缀。这里我们就引出了一个 最长公共前后缀，最长公共前后缀就是当我们分析的字符串中有多个公共前后缀时，我们要取最长的公共前后缀。

5第五周用Range实现CSSOM精准操作
模仿Reactive实现原理
给对象做一个简单的包装。 Vue 3.0 其中一个改动就是把 Vue 原来的能力拆了一个包，产生了一个叫reactive 的这一个单独的包。
双向绑定好处：
双向绑定强大之处在于在很多时候我们交互不需要使用代码，即可实现交互。其实用Jquery做很多的交互逻辑代码，需要写很多的逻辑和update代码来实现一个交互的过程，而有了双向绑定后，可以花更多时间精力专注于编写Vue和输入的关系。
这个练习对我们学习和掌握vue3有很大帮助。
使用Range和CSSOM做了一个练习，实现一个简单的拖拽功能。拖拽就是把一个在浏览器上的盒子捡起来，然后用鼠标可以拖动这个盒子到任意的位置。
通过实现这个功能，更进一步的认识到range和CSSOM在DOM API里面的一些应用场景。
 
6~7周主要是重学javascript笔记整理
1 语言按语法分类
非形式语言（中文，英文），特点是语法没有严格的定义
形式语言（计算机中大部分语言）：特点有一个形式化定义，严谨

形式语言分类方法：乔姆斯基谱系：
0- 型文法（无限制文法或短语结构文法）包括所有的文法。
1- 型文法（上下文相关文法）生成上下文相关语言。
2- 型文法（上下文无关文法）生成上下文无关语言。
3- 型文法（正规文法）生成正则语言。

2产生式（BNF）
概念：计算机中指编译器将源代码经过词法分析和语法分析之后得到一系列符合文法规则的语句。
用尖括号括起来的表示 ## 语法结构 ## 名（像if语句，函数，字符串直接量）
语法结构分为基础语法结构和由其他语法结构组合表示的一个复合结构。
- 基础结构称为终结符
- 复合结构称为非终结符
- 引号和中间的字符表示终结符（即字符串表示终结符）
- 可以有括号
- *表示重复多次
- |表示或
- +表示至少一次

例子
一个四则运算例子：1 + 2 * 3。要用产生式表示这种类型的四则运算，可以将式子看成是表达式相加。可以定义基本的表达式
乘法表达式：  <MultiplicativeExpression>::=<Number> |
             <MutiplicativeExpression> "*" <Number> |
             <MutiplicativeExpression> "/" <Number> |

加法表达式 ： <AddtiveExpression>::= <MultiplicativeExpression> |
             <AddtiveExpression> "+" <Number> |
             <AddtiveExpression> "-" <Number>

在此基础上加带括号的四则运算：
<WithBracketsExpression>::= "("<AddtiveExpression>")" | <Number>


3语言的分类
 形式语言，根据用途分类，可以按如下进行分类
 数据描述语言（本身不能进行编程）：
 css,json,html,xaml,sql
 编程语言：
 c,c++,c#,java,python,ruby,perl,lisp,t-sql,clojure,haskell,javascript

形式语言--表达方式分类
申明式语言：
css,json,html,xaml,sql,lisp,clojure,haskell
命令式语言：
c,c++,c#,java,javascript,python,ruby,perl

4编程语言性质：
- 图灵完备性：
命令式--图灵机
goto
if和while
申明式--lambad
递归

- 动态与静态
动态：在用户的设备，在线服务器上
产品实际运行时
Runtime
静态：
在程序员设备上
产品开发时
Compiletime

类型系统
动态类型系统 —— 在用户机器上可以找到的类型时
JavaScript就是动态类型系统
静态类型系统 —— 只在程序员编写代码的时候可以找到的类型时
C++最终编译到目标的机器的代码的时候，所有的类型信息都被丢掉了
半动态半静态类型系统 —— 比如 Java 一类的语言提供了反射机制
在编译时主要的类型检查和类型的操作，都已经在编译时被处理掉了
但是如果你想在运行时去获得类型信息，还是可以通过反射去获取的
强类型与弱类型 —— 说明在编程语言里类型转换发生的形式
强类型： 无隐式转换（类型转化是不会默认发生的）
弱类型： 有隐式转换（JavaScript 就是典型的弱类型的语言，默认吧 Number 转换成 String 类型然后相加后给你得到一个 String 类型，还有 String 和 Boolean 双等运算，会先把 Boolean 转成 Number 然后再跟 String 去做是否相同的对比）
复合类型
结构体
函数签名（包含参数类型和返回值类型两个部分）
子类型 —— 典型的语言就是 C++（在做类型转换的时候，会有一些默认的行为）
范型
协变与逆变： https://jkchao.github.io/typescript-book-chinese/tips/covarianceAndContravariance.html
协变例子：凡是能用范型数组 Array <Parent> 的地方都能用 Array <Child>
逆变例子：凡是能用 Function <Child> 的地方，都能用 Function <Parent>

一般命令式编程语言的设计方式：
原子级（Atom）—— 一个语言的最小的组成单位
关键字（Identifier）
字符/数字的直接量（Literal）
变量名（Variables）
表达式（Expression）—— 原子级结构通过运算符相连接和辅助符号形成
原子单位（Atom）
操作符（Operator）—— 加减乘除，拼接符等等
语法符（Punctuator）
语句（Statement）—— 表达式加上特定的标识符、关键字、符号形成一定的结构
表达式（Expression）
关键字（Keyword）
语法符（Punctuator）
结构化（Structure）—— 帮助我们组织、分块、分成不同的复用结构
函数（Function）
类（Class）
过程（Process）—— PASCAL 语言就会有 Process 的概念
命名空间（Namespace）—— C++ / PHP 中就会有 Namespace 的概念
程序（Program）—— 管理语言模块和安装
程序（Program）—— 实际执行的代码
模块（Module）—— 准备好被复用的模块
包（Package）
库（Library）

JavaScript 中的类型
数字类型（Number）
这个在小学的时候就认识了
但是到了 JavaScript 当中就不是小学时候理解的那个概念了
字符类型（String）
这个到了学编程的时候都会知道的概念
布尔类型（Boolean）
表示真值
计算机领域的 true 和 false，是把日常生活中真假的概念做了一个抽象
对象（Object）
Object 历史渊源比较久
Null
代表的是有值，但是是空
有一个设计 bug，typeof null 值的变量时会出来 Object，这个只能忍耐了，因为官方也声明过不会修复的。
Undefined
本没有没有定义过这个值
Symbol
新加的基本类型
它一定程度上代替了 String 的作用
可以用于 Object 里的索引
与 String 最大的区别就是，String 全天下都一样，只要你能猜出 String 的内容是什么，无论前面后面加了多少个符号，只要别人想用，对象的属性总是能取出来。
Symbol 就不一样了，如果你取不到 Symbol，那里面的内容是不可能被取得的。这个也是 JavaScript 独特有的特性。

Object三要素：
Identifier —— 唯一标识
State —— 状态
Behavior —— 行为

第8~10周主要实现了一个toy-broswer
这三周刷新了我的认知，让我对浏览器的工作原理有了个大概的认知。
首先浏览器是由5个步骤完成的整体渲染
我们从URL访问一个网页，经过浏览器的解析和渲染后成为了Bitmap
最后通过我们的显卡驱动设配出去画面，让我们看到完成的页面
这是一个浏览器的渲染流程
这里我们只实现一个简单的基础流程，但是真正的浏览器还包含了很多功能，比如历史等等
老师带我们完成的是从URL请求到Bitmap页面展示的整个流程。

浏览器流程：

URL部分，经过HTTP请求，然后解析返回内容，然后提取HTML内容
得到HTML后，我们可以通过文本分析（parse），然后把HTML的文本编程一个DOM树
这个时候的DOM树是光秃秃的，下一步我们进行CSS计算（CSS computing），最终把CSS挂载在这个DOM树上
经过计算后，我们就拥有一个有样式的DOM树，这个时候我们就可以布局（或者排版）了
通过布局计算，每一个DOM都会得到一个计算后的盒（当然实际浏览器中是每个CSS都会生成一个盒，但是为了简化这个，我们这里只做到每个DOM只生成一个盒即可）
最后我们就可以开始渲染（Render），把这个DOM树该有背景图的有背景图，该有背景色的有背景色，最后把这些样式画到一张图片上。然后我们可以通过操作系统和硬件驱动提供的API接口，展示出来给用户看了。
前面学习了用状态机处理字符串，第一次接触状态机这个概念，对底层原理认知的第一步。
后面用node写服务器相对比较简单，主要实现toy-broswer，服务端没有过多的处理。

接下来就是客户端代码的书写，实现了一个请求类，这里面一个难点就是send函数这个构建模式，winter老师写法给了我启发，让我了解了Promise实际应用。紧接着用到了状态机解析发送的请求。

加入HTMLParser
上一篇文章中我们最后获得了一个Response对象
这里我们就考虑如何利用这个Response中的body内容
 所以我们应该从获得Response之后，把body内容传给parser中的parseHTML方法进行解析
在真正的浏览器中，我们是应该逐段的传给parser处理，然后逐段的返回
因为这里我们的目标只是简单实现浏览器工作的原理，所以只需要统一解析然后返回就好
，更容易理解，代码也更加清晰易懂。

CSS计算
完成HTML解析并且获得了我们的DOM树之后，我们可以通过CSS计算来生成带CSS的DOM树。CSSComputing表示的就是我们CSS规则里面所包含的那些CSS属性，应用到匹配这些选择器的元素上。
这个过程借助了css这个包，简化过程。

排版渲染
根据浏览器的属性来进行排版。
这个阶段主要是跟着老师代码。刚开始不能理解老师的一些步骤，到了后面就能融会贯通一点。
总的来说过程比较痛苦。有时候调试较长时间。

总结：总的来说课程难度较大。很多地方需要自己的思考。当然也会学到新的知识，编程思维。这个是比较难得的。